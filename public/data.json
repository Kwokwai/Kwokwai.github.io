[{"title":"从零开始的react之路(1)--JSX","tag":["前端","react"],"time":"2019-08-19 12:50:09","url":"/post/1566190209","content":"## 一、什么是JSX\n\n```js\nconst element = <h1>Hello,world!</h1>\n```\n类似这种语法，既有点像JS的表达式，又像HTML表达的结构便是JSX。\n\nJSX是一个JavaScript的语法扩展，其本质目的是为了使用xml的方式来表达组件的嵌套，从而与HTML保持一致的结构。\n\nJSX通过Babel编译后，就能得到相应的JS结构。\n\n## 二、JSX的基本特性\n### 1、使用表达式\n\n#### 嵌入表达式\n\n```js\nconst name = 'Kwok'\nconst element = <h1>Hello, {name}</h1>\n\nReactDom.render(\n\telement,\n\tdocument.getElementById('root')\n)\n```\n上面这个例子中，我们定义了一个`name`的变量，然后在JSX中用包含在大括号内，这就是在JSX中的嵌入表达式。\n\n我们可以在大括号内放置任何有效的JavaScript的表达式。例如：`2 + 2`、`user.name`、`formatName(user)`等都是有效的JavaScript表达式。在下面例子，我们将把`formatName(user)`嵌入到JSX中。\n\n```js\nfunction formatName(user) {\n\treturn user.firstName + ' ' + user.lastName\n}\n\nconst user = {\n\tfirstName: 'Kwok',\n\tlastName: 'Vaileung'\n}\n\nconst element = (\n\t<h1>\n\t\tHello, {formatName(user}!\n\t</h1>\n)\n\nReactDOM.render(\n\telement,\n\tdocument.getElementById('root')\n)\n```\n\n#### 自身也是一种表达式\n通过编译后，JSX表达式会变转化为JS表达式，所以，在JSX中我们可以使用`if`语句和`for`循环语句。\n\n```js\nfunction getGreeting(user) {\n\tif (user) {\n\t\treturn <h1>Hello, {fiormatName(user)}!</h1>\n\t}\n\treturn <h1>Hello, Stranger.</h1>\n}\n```\n\n### 2、指定属性\n\nJSX可以使用引号来定义以字符串为值的属性：\n\n```js\nconst element = <div tabIndex=\"0\"></div>;\n```\n\n也可以使用大括号来定义以JavaScript表达式为值的属性：\n\n```js\nconst element = <img src={user.avatarUrl} />;\n```\n\n因为JSX的特性更接近JavaScript而不是HTML，所以React DOM使用camelCase（小驼峰）命名来定义属性的名称，而不是使用HTML的属性名称。例如：class变成了className，而tabindex则对应着tableIndex。\n\n### 3、闭合格式\n#### 自闭合\n假如标签内没有其他内容，则可以像XMl语法一样用`/>`来闭合标签。\n\n```js\nconst element = <img src={user.avatarUrl}/>\n```\n\n#### 标签闭合\nJSX标签允许嵌套多个子标签\n\n```js\nconst element = (\n\t<div>\n\t\t<h1>Hello!</div>\n\t\t<h2>Nice to meet you!</h2>\n\t</div>\n)\n```\n\n### 4、防止注入攻击\nReact DOM在渲染之前默认会过滤所有传入的值。它可以确保应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止XSS（跨站脚本攻击）。\n\n所以在JSX中嵌入用户输入是安全的。\n\n```js\nconst title = response.potentiallyMaliciousInput;\nconst element = <h1>{title}</h1>;\n```\n\n### 5、JSX表示为对象\n```js\nconst element = (\n\t<h1 className=\"greeting\">\n\t\tHello, world!\n\t</h1>\n)\n```\n\n上面这段代码跟下面那段代码是等效的，因为Babel会把JSX编译成一个名为`React.createElement()`的函数调用。\n\n```js\nconst element = React.createElement(\n\t'h1',\n\t{className: 'greeting'},\n\t'Hello, world!'\n)\n```\n\n`React.createElement`创建了一个对象,这种对象被称为\"React 元素\",它可以描述我们的HTML结构的信息，包括标签名、属性、子元素等，当获得这些HTML结构的信息后，React就能帮我们构建DOM元素然后展示到我们所看到的页面。\n\n以下便是`React.createElement`所构建的一个对象：\n\n```js\ncosnt element = {\n\ttype: 'h1',\n\tprops: {\n\t\tclassName: 'greeting',\n\t\tchildren: 'Hello, world!'\n\t}\n}\n```\n\n","summary":"\n## 一、什么是JSX\n\n```js\nconst element = <h1>Hello,world!</h1>\n```\n类似这种语法，既有点像JS的表达式，又像HTML表达的结构便是JSX。\n\nJ"},{"title":"从零开始的react之路(2)--虚拟DOM&元素渲染","tag":["前端","react"],"time":"2019-08-21 10:56:17","url":"/post/1566356177","content":"## 1、虚拟DOM\nJSX会被转移成`React.createElement`的方法\n而这个方法所构成的对象，便是虚拟DOM。\n\n```js\nconst element = {\n\ttype: 'h1',\n\tprops: {\n\t\tclassName: 'greeting',\n\t\tchildren: 'Hello,world!'\n\t}\n}\n```\n\n## 2、元素渲染为DOM\n```js\nconst element = <h1>Hello, world</h1>\nReactDOM.render(\n\telement,\n\tdocument.getElementById('root')\n)\n```\n\n上面这段代码便是将React元素渲染为DOM的过程，其中起重要作用的是`ReactDOM.render()`。\n\n以下这段代码则是上面那段代码转化后所展示的出来的，因此`render`所接收的第一个参数是createElement返回的对象，也就是虚拟DOM，第二个参数是挂载目标。由此可见，`ReactDOM.render()`的作用是将虚拟DOM转化为真实DOM。\n\n```js\nReactDOM.render(\n\tReact.createElement('h1', null,'Hello,world!')\n\tdocument.getElementById('root')\n)\n```\n\n## 3、更新渲染过的元素\nReact元素是不可变对象，即元素一旦被创建，其元素或者属性是固定的，无法进行更改，而我们所看到的页面或UI则是由许多这样的元素所组成，那么当我们要更新页面或者UI时，唯一的办法就是重新创建一个新的元素，然后再由`ReactDOM.render()`渲染出来。\n\n```js\nfunctiontick() {\n\tconst elemetn = (\n\t\t<div>\n\t\t\t<h1>Hello, world!</h1>\n\t\t\t<h2>It is {new Date().toLocaleTimeString()}\n\t\t\t</h2>\n\t\t</div>\n\t)\n\tReactDOM.render(\n\t\telement,\n\t\tdocument.getElementById('root')\n\t)\n}\n\nsetInterval(tick, 1000)\n```\n\n上面这段代码是一个计时器的例子，在`setInterval()`里回调，每秒调用一次`ReactDOM.render()`。\n","summary":"\n## 1、虚拟DOM\nJSX会被转移成`React.createElement`的方法\n而这个方法所构成的对象，便是虚拟DOM。\n\n```js\nconst element = {\n\ttype: 'h"},{"title":"从零开始的react之路(3)--组件","tag":["前端","react"],"time":"2019-08-22 12:38:29","url":"/post/1566448709","content":"## 1、组件的定义根据官方文档\"组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思\",组件可以接受任意的入参(即\"props\"),并返回React元素,我们所看到的UI便是由组件所声明。\n\n## 2、构建组件\n### (1)类组件\n```js\nclass Welcome extends React.Component {\n\trender() {\n\t\treturn <h1>Hello,{this.props.name}</h1>\n\t}\n}\n```\n以上代码片段为一个类组件例子。类组件拥有不同的生命周期,我们能够在不同的阶段(挂载、更新、卸载等)进行组件的控制，类组件能够维护自身的状态变量(state)。\n\n### (2)函数组件\n```js\nfunction Welcome(props) {\n\treturn <h1>Hello, {props.name}</h1>\n}\n```\n\n以上代码片段为一个函数组件例子。函数所构建成的组件是`无状态`组件,能够接收`props`和`context`两个参数,不能接收`state`,所以生命周期中只有`render()`,然后返回一个React元素。\n\n### (3)React.createClass()\n利用`createClass()`API来创建组件。\n\n```js\n//组件首字母必须要大写\nvar Greeting = React.createClass({\n\trender() {\n\t\treturn <h1>Hello,{this.props.name}</h1>\n\t}\n})\n```\n\n## 3、渲染组件\n\nReact元素可以是DOM标签,也可以是自定义的组件,当React元素为自定义组件时,JSX所接收到的属性会转化成单个对象然后传给组件,这个对象叫作\"props\"。\n\n```js\nfunction Welcome(props) {\n\treturn <h1>Hello, {props.name}</h1>\n}\n\nconst element = <Welcome name=\"kwok\" />\n\nReactDOM.render(\n\telement,\n\tdocument.getElementById('root')\n)\n```\n可以看到上面这段代码,首先调用了`ReactDOM.render()`函数,然后传入了`<Welcome name=\"kwok\" />`作为参数，接着React调用了自定义的`Weclome`组件,把`{name: 'kwok'}`作为props传入函数,`Welcome`组件把`<h1>Hello,kwok`</h1>作为返回值,最后ReactDOM把DOM更新为`<h1>Hello,kwok</h1>`。\n\n## 4、组合组件\n```js\nfunction Welcome(props) {\n\treturn <h1>Hello,{props.name}</h1>\n}\n\nfunction App() {\n\treturn (\n\t\t<div>\n\t\t\t<Welcome name=\"kwok\" />\n\t\t\t<Welcome mame=\"vai\" />\n\t\t\t<Welcome name=\"leung\" />\n\t\t</div>\n\t)\n}\n```\n\n上面这段代码里,`App`组件里多次渲染了`Welcome`组件,这是因为组件可以在其输出中引入其他组件。\n\n## 5、提取组件\n\n```js\nfunction Comment(props) {\n\treturn (\n\t\t<div className=\"comment\">\n\t\t\t<div className=\"UserInfo\">\n\t\t\t\t<img className=\"Avatar\" src={props.author.avatarUrl} alt={props.author.name} />\n\t\t\t\t<div className=\"UserInfoName>\n\t\t\t\t\t{props.author.name}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"CommentText\">\n\t\t\t\t{props.text}\n\t\t\t</div>\n\t\t\t<div className=\"CommentDate\">\n\t\t\t\t{formatDate(props.date)}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n```\n\n可以看到,以上代码的`props`对象为\n\n```js\nprops = {\n\tauthor: {\n\t\tavatarUrl: \"\",\n\t\tname: \"\"\n\t},\n\ttext: \"\",\n\tdate: \"\"\n}\n```\n\n`Comment`这个组件里嵌套了多层关系,大大提高以后维护的难度,所以我们可以在`Comment`里提取组件,达到复用效果。\n\n```js\nfunction Avatar(props){\n\treturn (\n\t\t<img className=\"Avatar\" src={props.user.avatarUrl} alt={props.user.name} />\n\t)\n}\n\nfunction UserInfo(props) {\n\treturn (\n\t\t<div className=\"UserInfo\">\n\t\t\t<Avatar user={props.user} />\n\t\t\t<div className=\"UserInfoName\">\n\t\t\t\t{props.user.name}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n```\n\n上面代码片段中,把`Avatar`和`UserInfo`提取出来,单独作为组件,以达到代码复用的效果。然后我们可以把`Comment`组件重新写过：\n\n```js\nfunction Comment(props) {\n\treturn (\n\t\t<div className=\"Comment\">\n\t\t\t<UserInfo user={props.author} />\n\t\t\t<div className=\"CommentText\">\n\t\t\t\t{props.text}\n\t\t\t</div>\n\t\t\t<div className=CommentDate\">\n\t\t\t\t{formatDate(props.date)}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n```\n\n","summary":"## 1、组件的定义\n根据官方文档\"组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思\",组件可以接受任意的入参(即\"props\"),并返回React元素,我们所看到的UI便是由"}]